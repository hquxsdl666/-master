# 中医脉象诊断系统 - 技术实现细节文档

## 一、PPG信号处理算法实现

### 1.1 信号预处理流程

```python
import numpy as np
from scipy import signal
from scipy.fft import fft
import pywt

class PPGSignalProcessor:
    """PPG信号处理器"""
    
    def __init__(self, sample_rate=100):
        self.sample_rate = sample_rate
        self.window_size = sample_rate * 2  # 2秒窗口
        
    def preprocess(self, ppg_signal):
        """
        完整的PPG信号预处理流程
        
        Args:
            ppg_signal: 原始PPG信号数组
            
        Returns:
            预处理后的信号
        """
        # 1. 去除趋势
        detrended = self.remove_trend(ppg_signal)
        
        # 2. 带通滤波 (0.5-8Hz，对应30-480次/分的心率范围)
        filtered = self.bandpass_filter(detrended, low=0.5, high=8.0)
        
        # 3. 陷波滤波 (去除50Hz工频干扰)
        notched = self.notch_filter(filtered, freq=50.0)
        
        # 4. 小波去噪
        denoised = self.wavelet_denoise(notched)
        
        # 5. 归一化
        normalized = self.normalize(denoised)
        
        return normalized
    
    def remove_trend(self, signal_data, window_size=None):
        """使用移动平均去除基线漂移"""
        if window_size is None:
            window_size = self.sample_rate  # 1秒窗口
        
        # 计算移动平均
        trend = np.convolve(signal_data, 
                           np.ones(window_size)/window_size, 
                           mode='same')
        
        # 去除趋势
        detrended = signal_data - trend
        return detrended
    
    def bandpass_filter(self, signal_data, low, high, order=4):
        """巴特沃斯带通滤波器"""
        nyquist = self.sample_rate / 2
        low_norm = low / nyquist
        high_norm = high / nyquist
        
        b, a = signal.butter(order, [low_norm, high_norm], btype='band')
        filtered = signal.filtfilt(b, a, signal_data)
        return filtered
    
    def notch_filter(self, signal_data, freq, quality=30):
        """陷波滤波器去除工频干扰"""
        nyquist = self.sample_rate / 2
        freq_norm = freq / nyquist
        
        b, a = signal.iirnotch(freq_norm, quality)
        notched = signal.filtfilt(b, a, signal_data)
        return notched
    
    def wavelet_denoise(self, signal_data, wavelet='db4', level=4):
        """小波变换去噪"""
        # 小波分解
        coeffs = pywt.wavedec(signal_data, wavelet, level=level)
        
        # 阈值去噪
        threshold = np.std(coeffs[-1]) * np.sqrt(2 * np.log(len(signal_data)))
        
        denoised_coeffs = []
        for i, coeff in enumerate(coeffs):
            if i == 0:  # 保留近似系数
                denoised_coeffs.append(coeff)
            else:  # 细节系数阈值处理
                denoised_coeff = pywt.threshold(coeff, threshold, mode='soft')
                denoised_coeffs.append(denoised_coeff)
        
        # 小波重构
        denoised = pywt.waverec(denoised_coeffs, wavelet)
        
        # 确保长度一致
        return denoised[:len(signal_data)]
    
    def normalize(self, signal_data, method='zscore'):
        """信号归一化"""
        if method == 'zscore':
            mean = np.mean(signal_data)
            std = np.std(signal_data)
            if std == 0:
                return signal_data - mean
            return (signal_data - mean) / std
        elif method == 'minmax':
            min_val = np.min(signal_data)
            max_val = np.max(signal_data)
            if max_val == min_val:
                return signal_data - min_val
            return (signal_data - min_val) / (max_val - min_val)
        else:
            return signal_data
```

### 1.2 特征提取实现

```python
class PulseFeatureExtractor:
    """脉象特征提取器"""
    
    def __init__(self, sample_rate=100):
        self.sample_rate = sample_rate
        self.min_peak_distance = int(0.4 * sample_rate)  # 最小峰值间距(0.4秒)
        
    def extract_all_features(self, ppg_signal):
        """
        提取所有脉象特征
        
        Args:
            ppg_signal: 预处理后的PPG信号
            
        Returns:
            dict: 特征字典
        """
        # 峰值检测
        peaks, valleys = self.detect_peaks(ppg_signal)
        
        if len(peaks) < 3:
            raise ValueError("信号质量不足，无法提取有效特征")
        
        # 分割单周期
        cycles = self.segment_cycles(ppg_signal, peaks, valleys)
        
        features = {}
        
        # 时域特征
        features['time_domain'] = self.extract_time_features(cycles)
        
        # 频域特征
        features['frequency_domain'] = self.extract_frequency_features(ppg_signal)
        
        # 形态特征
        features['morphology'] = self.extract_morphology_features(cycles)
        
        # 统计特征
        features['statistics'] = self.extract_statistical_features(ppg_signal, peaks)
        
        return features
    
    def detect_peaks(self, signal_data):
        """
        检测PPG信号的峰值和谷值
        
        Returns:
            peaks: 峰值索引列表
            valleys: 谷值索引列表
        """
        from scipy.signal import find_peaks
        
        # 检测峰值 (收缩峰)
        peaks, peak_properties = find_peaks(
            signal_data, 
            distance=self.min_peak_distance,
            prominence=0.1 * np.std(signal_data)
        )
        
        # 检测谷值 (通过取反信号)
        valleys, valley_properties = find_peaks(
            -signal_data,
            distance=self.min_peak_distance,
            prominence=0.1 * np.std(signal_data)
        )
        
        return peaks, valleys
    
    def segment_cycles(self, signal_data, peaks, valleys):
        """
        分割单周期波形
        
        Returns:
            list: 单周期波形列表
        """
        cycles = []
        
        for i in range(len(peaks) - 1):
            start = peaks[i]
            end = peaks[i + 1]
            
            # 提取单周期
            cycle = signal_data[start:end]
            
            # 存储周期信息
            cycle_info = {
                'waveform': cycle,
                'start_idx': start,
                'end_idx': end,
                'systolic_peak': np.max(cycle),
                'systolic_idx': np.argmax(cycle),
                'diastolic_peak': np.min(cycle),
                'diastolic_idx': np.argmin(cycle),
                'duration': (end - start) / self.sample_rate
            }
            
            cycles.append(cycle_info)
        
        return cycles
    
    def extract_time_features(self, cycles):
        """提取时域特征"""
        features = {}
        
        # 脉率相关
        durations = [c['duration'] for c in cycles]
        features['pulse_rate'] = 60 / np.mean(durations)  # 脉率(次/分)
        features['rate_variability'] = np.std(durations)  # 脉率变异性
        
        # 脉力相关
        systolic_amplitudes = [c['systolic_peak'] for c in cycles]
        diastolic_amplitudes = [c['diastolic_peak'] for c in cycles]
        
        features['systolic_amplitude_mean'] = np.mean(systolic_amplitudes)
        features['systolic_amplitude_std'] = np.std(systolic_amplitudes)
        features['diastolic_amplitude_mean'] = np.mean(diastolic_amplitudes)
        features['pulse_pressure'] = np.mean(systolic_amplitudes) - np.mean(diastolic_amplitudes)
        
        # 脉宽相关 (半峰宽)
        half_widths = []
        for cycle in cycles:
            waveform = cycle['waveform']
            peak_val = cycle['systolic_peak']
            half_val = peak_val / 2
            
            # 找到半峰位置
            above_half = waveform > half_val
            if np.any(above_half):
                width = np.sum(above_half) / self.sample_rate
                half_widths.append(width)
        
        features['pulse_width'] = np.mean(half_widths) if half_widths else 0
        
        # 上升/下降时间
        rising_times = []
        falling_times = []
        
        for cycle in cycles:
            waveform = cycle['waveform']
            systolic_idx = cycle['systolic_idx']
            
            # 上升时间 (从起点到峰值)
            rising_time = systolic_idx / self.sample_rate
            rising_times.append(rising_time)
            
            # 下降时间 (从峰值到终点)
            falling_time = (len(waveform) - systolic_idx) / self.sample_rate
            falling_times.append(falling_time)
        
        features['rising_time'] = np.mean(rising_times)
        features['falling_time'] = np.mean(falling_times)
        features['rise_fall_ratio'] = np.mean(rising_times) / np.mean(falling_times)
        
        return features
    
    def extract_frequency_features(self, signal_data):
        """提取频域特征"""
        features = {}
        
        # FFT变换
        n = len(signal_data)
        fft_vals = fft(signal_data)
        fft_freqs = np.fft.fftfreq(n, 1/self.sample_rate)
        
        # 只取正频率
        positive_freqs = fft_freqs[:n//2]
        positive_fft = np.abs(fft_vals[:n//2])
        
        # 主频率
        dominant_idx = np.argmax(positive_fft)
        features['dominant_freq'] = positive_freqs[dominant_idx]
        
        # 功率谱密度
        psd = positive_fft ** 2
        
        # 频带功率
        # 极低频 (VLF): 0.003-0.04 Hz
        vlf_mask = (positive_freqs >= 0.003) & (positive_freqs < 0.04)
        features['vlf_power'] = np.sum(psd[vlf_mask])
        
        # 低频 (LF): 0.04-0.15 Hz
        lf_mask = (positive_freqs >= 0.04) & (positive_freqs < 0.15)
        features['lf_power'] = np.sum(psd[lf_mask])
        
        # 高频 (HF): 0.15-0.4 Hz
        hf_mask = (positive_freqs >= 0.15) & (positive_freqs < 0.4)
        features['hf_power'] = np.sum(psd[hf_mask])
        
        # 低高频比
        if features['hf_power'] > 0:
            features['lf_hf_ratio'] = features['lf_power'] / features['hf_power']
        else:
            features['lf_hf_ratio'] = 0
        
        # 总功率
        features['total_power'] = np.sum(psd)
        
        # 谱熵
        psd_norm = psd / np.sum(psd)
        spectral_entropy = -np.sum(psd_norm * np.log2(psd_norm + 1e-10))
        features['spectral_entropy'] = spectral_entropy
        
        return features
    
    def extract_morphology_features(self, cycles):
        """提取形态特征"""
        features = {}
        
        # 重搏切迹检测
        dicrotic_notches = []
        waveform_areas = []
        
        for cycle in cycles:
            waveform = cycle['waveform']
            systolic_idx = cycle['systolic_idx']
            
            # 在降支寻找重搏切迹
            descending = waveform[systolic_idx:]
            if len(descending) > 3:
                # 寻找局部极小值作为重搏切迹
                from scipy.signal import find_peaks
                notches, _ = find_peaks(-descending, distance=3)
                
                if len(notches) > 0:
                    notch_idx = notches[0] + systolic_idx
                    notch_depth = waveform[systolic_idx] - waveform[notch_idx]
                    dicrotic_notches.append(notch_depth)
            
            # 波形面积
            area = np.trapz(waveform)
            waveform_areas.append(area)
        
        features['dicrotic_notch_depth'] = np.mean(dicrotic_notches) if dicrotic_notches else 0
        features['has_dicrotic_notch'] = len(dicrotic_notches) > len(cycles) * 0.5
        features['waveform_area'] = np.mean(waveform_areas)
        
        # 波形不对称性
        asymmetries = []
        for cycle in cycles:
            waveform = cycle['waveform']
            systolic_idx = cycle['systolic_idx']
            
            # 计算前后面积比
            front_area = np.trapz(waveform[:systolic_idx])
            back_area = np.trapz(waveform[systolic_idx:])
            
            if back_area > 0:
                asymmetry = front_area / back_area
                asymmetries.append(asymmetry)
        
        features['waveform_asymmetry'] = np.mean(asymmetries) if asymmetries else 1.0
        
        # 波形复杂度 (使用近似熵)
        features['waveform_complexity'] = self.approximate_entropy(
            np.concatenate([c['waveform'] for c in cycles])
        )
        
        return features
    
    def extract_statistical_features(self, signal_data, peaks):
        """提取统计特征"""
        features = {}
        
        # 基本统计量
        features['mean'] = np.mean(signal_data)
        features['std'] = np.std(signal_data)
        features['skewness'] = np.mean(((signal_data - features['mean']) / features['std']) ** 3)
        features['kurtosis'] = np.mean(((signal_data - features['mean']) / features['std']) ** 4) - 3
        
        # 峰值间期统计
        if len(peaks) > 1:
            peak_intervals = np.diff(peaks) / self.sample_rate
            features['peak_interval_mean'] = np.mean(peak_intervals)
            features['peak_interval_std'] = np.std(peak_intervals)
            features['peak_interval_cv'] = features['peak_interval_std'] / features['peak_interval_mean']
        else:
            features['peak_interval_mean'] = 0
            features['peak_interval_std'] = 0
            features['peak_interval_cv'] = 0
        
        # 信号能量
        features['signal_energy'] = np.sum(signal_data ** 2)
        
        # 过零率
        zero_crossings = np.sum(np.diff(np.sign(signal_data)) != 0)
        features['zero_crossing_rate'] = zero_crossings / len(signal_data)
        
        return features
    
    def approximate_entropy(self, signal_data, m=2, r=0.2):
        """计算近似熵"""
        def _phi(m):
            x = np.array([signal_data[i:i+m] for i in range(len(signal_data)-m+1)])
            C = np.sum(np.abs(x[:, None] - x[None, :]).max(axis=2) <= r, axis=0) / (len(signal_data)-m+1)
            return np.sum(np.log(C)) / (len(signal_data)-m+1)
        
        return _phi(m) - _phi(m+1)
```

## 二、脉象分类模型实现

### 2.1 轻量级神经网络模型

```python
import torch
import torch.nn as nn
import torch.nn.functional as F

class LightweightPulseNet(nn.Module):
    """
    轻量级脉象分类网络
    适用于华为GT4手表的边缘推理
    """
    
    def __init__(self, num_classes=28, input_channels=1):
        super(LightweightPulseNet, self).__init__()
        
        # 特征提取层
        self.features = nn.Sequential(
            # Block 1
            nn.Conv1d(input_channels, 16, kernel_size=7, stride=2, padding=3),
            nn.BatchNorm1d(16),
            nn.ReLU(inplace=True),
            nn.MaxPool1d(kernel_size=3, stride=2, padding=1),
            
            # Block 2
            nn.Conv1d(16, 32, kernel_size=3, stride=1, padding=1),
            nn.BatchNorm1d(32),
            nn.ReLU(inplace=True),
            nn.MaxPool1d(kernel_size=3, stride=2, padding=1),
            
            # Block 3
            nn.Conv1d(32, 64, kernel_size=3, stride=1, padding=1),
            nn.BatchNorm1d(64),
            nn.ReLU(inplace=True),
            nn.AdaptiveAvgPool1d(1)
        )
        
        # 分类器
        self.classifier = nn.Sequential(
            nn.Dropout(0.3),
            nn.Linear(64, 128),
            nn.ReLU(inplace=True),
            nn.Dropout(0.3),
            nn.Linear(128, num_classes)
        )
        
    def forward(self, x):
        x = self.features(x)
        x = x.view(x.size(0), -1)
        x = self.classifier(x)
        return x


class PulseFeatureFusionNet(nn.Module):
    """
    多特征融合脉象分类网络
    融合时域、频域、形态特征
    """
    
    def __init__(self, num_classes=28):
        super(PulseFeatureFusionNet, self).__init__()
        
        # 时域特征分支
        self.time_branch = nn.Sequential(
            nn.Linear(10, 32),
            nn.ReLU(),
            nn.Dropout(0.2),
            nn.Linear(32, 16)
        )
        
        # 频域特征分支
        self.freq_branch = nn.Sequential(
            nn.Linear(8, 32),
            nn.ReLU(),
            nn.Dropout(0.2),
            nn.Linear(32, 16)
        )
        
        # 形态特征分支
        self.morph_branch = nn.Sequential(
            nn.Linear(6, 32),
            nn.ReLU(),
            nn.Dropout(0.2),
            nn.Linear(32, 16)
        )
        
        # 融合层
        self.fusion = nn.Sequential(
            nn.Linear(48, 64),
            nn.ReLU(),
            nn.Dropout(0.3)
        )
        
        # 分类器
        self.classifier = nn.Sequential(
            nn.Linear(64, 128),
            nn.ReLU(),
            nn.Dropout(0.3),
            nn.Linear(128, num_classes)
        )
        
    def forward(self, time_features, freq_features, morph_features):
        # 各分支处理
        time_out = self.time_branch(time_features)
        freq_out = self.freq_branch(freq_features)
        morph_out = self.morph_branch(morph_features)
        
        # 特征拼接
        fused = torch.cat([time_out, freq_out, morph_out], dim=1)
        
        # 融合
        fused = self.fusion(fused)
        
        # 分类
        output = self.classifier(fused)
        
        return output
```

### 2.2 模型量化与优化

```python
import torch.quantization

class ModelOptimizer:
    """模型优化器"""
    
    @staticmethod
    def quantize_model(model, example_input):
        """
        模型量化 (INT8)
        减少模型大小和推理时间
        """
        # 设置量化配置
        model.qconfig = torch.quantization.get_default_qconfig('fbgemm')
        
        # 准备量化
        model_prepared = torch.quantization.prepare(model)
        
        # 校准 (使用示例数据)
        model_prepared(example_input)
        
        # 转换为量化模型
        model_quantized = torch.quantization.convert(model_prepared)
        
        return model_quantized
    
    @staticmethod
    def prune_model(model, pruning_ratio=0.3):
        """
        模型剪枝
        减少模型参数量
        """
        import torch.nn.utils.prune as prune
        
        # 对卷积层和全连接层进行剪枝
        for name, module in model.named_modules():
            if isinstance(module, (nn.Conv1d, nn.Linear)):
                prune.l1_unstructured(module, name='weight', amount=pruning_ratio)
                prune.remove(module, 'weight')
        
        return model
    
    @staticmethod
    def export_to_onnx(model, example_input, save_path):
        """导出为ONNX格式"""
        torch.onnx.export(
            model,
            example_input,
            save_path,
            input_names=['input'],
            output_names=['output'],
            dynamic_axes={'input': {0: 'batch_size'}, 'output': {0: 'batch_size'}},
            opset_version=11
        )
    
    @staticmethod
    def convert_to_tflite(pytorch_model, example_input, save_path):
        """转换为TensorFlow Lite格式 (用于Android)"""
        # 先导出为ONNX
        onnx_path = save_path.replace('.tflite', '.onnx')
        ModelOptimizer.export_to_onnx(pytorch_model, example_input, onnx_path)
        
        # 使用onnx-tf转换为TensorFlow
        import onnx
        from onnx_tf.backend import prepare
        
        onnx_model = onnx.load(onnx_path)
        tf_rep = prepare(onnx_model)
        
        # 保存TensorFlow模型
        tf_path = save_path.replace('.tflite', '_tf')
        tf_rep.export_graph(tf_path)
        
        # 转换为TFLite
        import tensorflow as tf
        converter = tf.lite.TFLiteConverter.from_saved_model(tf_path)
        converter.optimizations = [tf.lite.Optimize.DEFAULT]
        tflite_model = converter.convert()
        
        # 保存
        with open(save_path, 'wb') as f:
            f.write(tflite_model)
```

## 三、手表端服务实现

### 3.1 脉象采集服务

```typescript
// HarmonyOS 手表端脉象采集服务 (ArkTS)

import sensor from '@ohos.sensor';
import wearEngine from '@ohos.wearEngine';
import distributedData from '@ohos.data.distributedData';

class PulseAcquisitionService {
  private ppgSensor: sensor.Sensor | null = null;
  private accSensor: sensor.Sensor | null = null;
  private isCollecting: boolean = false;
  private ppgData: Float32Array = new Float32Array(6000); // 60秒 * 100Hz
  private dataIndex: number = 0;
  private sampleRate: number = 100;
  private duration: number = 60; // 采集时长(秒)
  
  // 信号质量评估回调
  private qualityCallback: ((quality: number) => void) | null = null;
  
  constructor() {
    this.initSensors();
  }
  
  private initSensors(): void {
    // 初始化PPG传感器
    this.ppgSensor = sensor.getSensor(
      sensor.SensorId.SENSOR_ID_HEART_RATE, 
      (data) => {
        if (this.isCollecting && this.dataIndex < this.ppgData.length) {
          this.ppgData[this.dataIndex++] = data.ppg;
          
          // 实时质量评估
          if (this.dataIndex % 100 === 0) {
            this.assessSignalQuality();
          }
        }
      }
    );
    
    // 初始化加速度计 (用于运动检测)
    this.accSensor = sensor.getSensor(
      sensor.SensorId.SENSOR_ID_ACCELEROMETER,
      (data) => {
        // 检测运动状态
        const motion = Math.sqrt(data.x**2 + data.y**2 + data.z**2);
        if (motion > 1.5) {
          // 检测到运动，提醒用户保持静止
          this.onMotionDetected();
        }
      }
    );
  }
  
  public startCollection(duration: number = 60): Promise<boolean> {
    return new Promise((resolve, reject) => {
      if (this.isCollecting) {
        reject(new Error('采集已在进行中'));
        return;
      }
      
      this.duration = duration;
      this.dataIndex = 0;
      this.ppgData = new Float32Array(duration * this.sampleRate);
      this.isCollecting = true;
      
      // 启动传感器
      this.ppgSensor?.start();
      this.accSensor?.start();
      
      // 设置定时器结束采集
      setTimeout(() => {
        this.stopCollection();
        resolve(true);
      }, duration * 1000);
    });
  }
  
  public stopCollection(): void {
    this.isCollecting = false;
    this.ppgSensor?.stop();
    this.accSensor?.stop();
  }
  
  private assessSignalQuality(): void {
    // 简单的信号质量评估
    const recentData = this.ppgData.slice(Math.max(0, this.dataIndex - 200), this.dataIndex);
    
    // 计算信噪比
    const mean = recentData.reduce((a, b) => a + b, 0) / recentData.length;
    const variance = recentData.reduce((a, b) => a + (b - mean)**2, 0) / recentData.length;
    const snr = mean / Math.sqrt(variance);
    
    // 质量分数 (0-1)
    const quality = Math.min(1, snr / 10);
    
    this.qualityCallback?.(quality);
  }
  
  private onMotionDetected(): void {
    // 通知UI层检测到运动
    // 可以震动提醒用户
    vibrator.start({
      type: 'time',
      duration: 200
    });
  }
  
  public getCollectedData(): Float32Array {
    return this.ppgData.slice(0, this.dataIndex);
  }
  
  public setQualityCallback(callback: (quality: number) => void): void {
    this.qualityCallback = callback;
  }
}
```

### 3.2 边缘推理服务

```typescript
// 手表端边缘推理服务

import ai from '@ohos.ai';

class EdgeInferenceService {
  private interpreter: ai.Interpreter | null = null;
  private modelPath: string = '/data/pulse_model.tflite';
  
  constructor() {
    this.loadModel();
  }
  
  private async loadModel(): Promise<void> {
    try {
      // 加载TensorFlow Lite模型
      this.interpreter = await ai.createInterpreter({
        model: this.modelPath,
        numThreads: 2  // 使用2线程优化性能
      });
      
      console.info('模型加载成功');
    } catch (error) {
      console.error('模型加载失败:', error);
    }
  }
  
  public async infer(ppgData: Float32Array): Promise<PulseInferenceResult> {
    if (!this.interpreter) {
      throw new Error('模型未加载');
    }
    
    // 预处理信号
    const processedData = this.preprocessSignal(ppgData);
    
    // 运行推理
    const inputTensor = new ai.Tensor('float32', processedData, [1, processedData.length]);
    const outputTensor = new ai.Tensor('float32', new Float32Array(28), [1, 28]);
    
    await this.interpreter.run([inputTensor], [outputTensor]);
    
    // 解析结果
    const probabilities = Array.from(outputTensor.data);
    const result = this.parseInferenceResult(probabilities);
    
    return result;
  }
  
  private preprocessSignal(ppgData: Float32Array): Float32Array {
    // 1. 降采样到50Hz (减少计算量)
    const downsampled = this.downsample(ppgData, 2);
    
    // 2. 归一化
    const mean = downsampled.reduce((a, b) => a + b, 0) / downsampled.length;
    const std = Math.sqrt(downsampled.reduce((a, b) => a + (b - mean)**2, 0) / downsampled.length);
    const normalized = downsampled.map(x => (x - mean) / (std + 1e-8));
    
    // 3. 截断或填充到固定长度 (3000点 = 60秒 @ 50Hz)
    const targetLength = 3000;
    if (normalized.length >= targetLength) {
      return normalized.slice(0, targetLength);
    } else {
      const padded = new Float32Array(targetLength);
      padded.set(normalized);
      return padded;
    }
  }
  
  private downsample(data: Float32Array, factor: number): Float32Array {
    const result = new Float32Array(Math.floor(data.length / factor));
    for (let i = 0; i < result.length; i++) {
      result[i] = data[i * factor];
    }
    return result;
  }
  
  private parseInferenceResult(probabilities: number[]): PulseInferenceResult {
    // 脉象类型列表
    const pulseTypes = [
      '浮脉', '沉脉', '迟脉', '数脉', '虚脉', '实脉',
      '滑脉', '涩脉', '弦脉', '紧脉', '洪脉', '细脉',
      '濡脉', '弱脉', '微脉', '散脉', '芤脉', '革脉',
      '牢脉', '伏脉', '缓脉', '结脉', '代脉', '促脉',
      '疾脉', '动脉', '长脉', '短脉'
    ];
    
    // 找到概率最高的脉象
    let maxProb = 0;
    let maxIndex = 0;
    for (let i = 0; i < probabilities.length; i++) {
      if (probabilities[i] > maxProb) {
        maxProb = probabilities[i];
        maxIndex = i;
      }
    }
    
    // 找到次高概率的脉象
    let secondMaxProb = 0;
    let secondMaxIndex = -1;
    for (let i = 0; i < probabilities.length; i++) {
      if (i !== maxIndex && probabilities[i] > secondMaxProb) {
        secondMaxProb = probabilities[i];
        secondMaxIndex = i;
      }
    }
    
    return {
      mainPulse: pulseTypes[maxIndex],
      mainPulseConfidence: maxProb,
      secondaryPulse: secondMaxIndex >= 0 ? pulseTypes[secondMaxIndex] : null,
      secondaryPulseConfidence: secondMaxProb,
      allProbabilities: probabilities.map((p, i) => ({
        pulse: pulseTypes[i],
        probability: p
      })).sort((a, b) => b.probability - a.probability)
    };
  }
}

interface PulseInferenceResult {
  mainPulse: string;
  mainPulseConfidence: number;
  secondaryPulse: string | null;
  secondaryPulseConfidence: number;
  allProbabilities: Array<{pulse: string, probability: number}>;
}
```

## 四、Android客户端API设计

### 4.1 RESTful API

```yaml
# API规范 (OpenAPI 3.0)

openapi: 3.0.0
info:
  title: 中医脉象诊断系统API
  version: 1.0.0
  description: 中医脉象诊断系统后端API接口

paths:
  # 用户认证
  /api/v1/auth/login:
    post:
      summary: 用户登录
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                phone:
                  type: string
                password:
                  type: string
                verifyCode:
                  type: string
      responses:
        200:
          description: 登录成功
          content:
            application/json:
              schema:
                type: object
                properties:
                  token:
                    type: string
                  user:
                    $ref: '#/components/schemas/User'

  /api/v1/auth/register:
    post:
      summary: 用户注册
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                phone:
                  type: string
                password:
                  type: string
                verifyCode:
                  type: string
                nickname:
                  type: string
      responses:
        201:
          description: 注册成功

  # 脉诊记录
  /api/v1/pulse/records:
    get:
      summary: 获取脉诊记录列表
      parameters:
        - name: page
          in: query
          schema:
            type: integer
            default: 1
        - name: size
          in: query
          schema:
            type: integer
            default: 20
        - name: startDate
          in: query
          schema:
            type: string
            format: date
        - name: endDate
          in: query
          schema:
            type: string
            format: date
      responses:
        200:
          description: 记录列表
          content:
            application/json:
              schema:
                type: object
                properties:
                  total:
                    type: integer
                  pages:
                    type: integer
                  records:
                    type: array
                    items:
                      $ref: '#/components/schemas/PulseRecord'

    post:
      summary: 上传脉诊记录
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PulseRecordInput'
      responses:
        201:
          description: 上传成功
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PulseRecord'

  /api/v1/pulse/records/{id}:
    get:
      summary: 获取单条脉诊记录详情
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        200:
          description: 记录详情
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PulseRecordDetail'

  /api/v1/pulse/analyze:
    post:
      summary: 分析脉象数据
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                ppgData:
                  type: string
                  description: Base64编码的PPG数据
                sampleRate:
                  type: integer
                  default: 100
      responses:
        200:
          description: 分析结果
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PulseAnalysisResult'

  # 方剂推荐
  /api/v1/prescriptions/recommend:
    post:
      summary: 根据脉象推荐方剂
      requestBody:
        content:
          application/json:
            schema:
              type: object
              properties:
                pulseRecordId:
                  type: string
                mainPulse:
                  type: string
                secondaryPulse:
                  type: string
                syndrome:
                  type: string
      responses:
        200:
          description: 推荐结果
          content:
            application/json:
              schema:
                type: object
                properties:
                  syndrome:
                    type: string
                  confidence:
                    type: number
                  recommendations:
                    type: array
                    items:
                      $ref: '#/components/schemas/PrescriptionRecommendation'

  /api/v1/prescriptions:
    get:
      summary: 获取方剂列表
      parameters:
        - name: category
          in: query
          schema:
            type: string
        - name: keyword
          in: query
          schema:
            type: string
      responses:
        200:
          description: 方剂列表
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Prescription'

  /api/v1/prescriptions/{id}:
    get:
      summary: 获取方剂详情
      parameters:
        - name: id
          in: path
          required: true
          schema:
            type: integer
      responses:
        200:
          description: 方剂详情
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PrescriptionDetail'

  # 统计报表
  /api/v1/statistics/trend:
    get:
      summary: 获取脉象趋势统计
      parameters:
        - name: period
          in: query
          schema:
            type: string
            enum: [week, month, quarter, year]
            default: month
      responses:
        200:
          description: 趋势数据
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PulseTrend'

  /api/v1/statistics/report:
    get:
      summary: 生成健康报告
      parameters:
        - name: startDate
          in: query
          required: true
          schema:
            type: string
            format: date
        - name: endDate
          in: query
          required: true
          schema:
            type: string
            format: date
      responses:
        200:
          description: 健康报告
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HealthReport'

components:
  schemas:
    User:
      type: object
      properties:
        id:
          type: string
        phone:
          type: string
        nickname:
          type: string
        avatar:
          type: string
        gender:
          type: integer
        age:
          type: integer
        constitution:
          type: string

    PulseRecord:
      type: object
      properties:
        id:
          type: string
        recordTime:
          type: string
          format: date-time
        mainPulse:
          type: string
        secondaryPulse:
          type: string
        pulseRate:
          type: integer
        syndrome:
          type: string
        confidence:
          type: number
        signalQuality:
          type: number

    PulseRecordDetail:
      allOf:
        - $ref: '#/components/schemas/PulseRecord'
        - type: object
          properties:
            pulseFeatures:
              type: object
            waveformData:
              type: string
            analysisReport:
              type: object

    PulseRecordInput:
      type: object
      properties:
        deviceId:
          type: string
        recordTime:
          type: string
          format: date-time
        duration:
          type: integer
        ppgData:
          type: string
        signalQuality:
          type: number
        pulseFeatures:
          type: object

    PulseAnalysisResult:
      type: object
      properties:
        mainPulse:
          type: string
        secondaryPulse:
          type: string
        pulseRate:
          type: integer
        pulseFeatures:
          type: object
        syndrome:
          type: string
        confidence:
          type: number

    Prescription:
      type: object
      properties:
        id:
          type: integer
        name:
          type: string
        category:
          type: string
        efficacy:
          type: string
        indications:
          type: string

    PrescriptionDetail:
      allOf:
        - $ref: '#/components/schemas/Prescription'
        - type: object
          properties:
            composition:
              type: array
              items:
                type: object
            dosage:
              type: string
            contraindications:
              type: string
            analysis:
              type: string

    PrescriptionRecommendation:
      type: object
      properties:
        prescription:
          $ref: '#/components/schemas/Prescription'
        matchScore:
          type: number
        rank:
          type: integer
        modifications:
          type: string

    PulseTrend:
      type: object
      properties:
        period:
          type: string
        dataPoints:
          type: array
          items:
            type: object
            properties:
              date:
                type: string
              mainPulse:
                type: string
              pulseRate:
                type: integer
              healthScore:
                type: integer

    HealthReport:
      type: object
      properties:
        period:
          type: string
        summary:
          type: string
        pulseDistribution:
          type: object
        syndromeDistribution:
          type: object
        healthTrend:
          type: string
        recommendations:
          type: array
          items:
            type: string
```

### 4.2 蓝牙通信协议

```kotlin
// Android蓝牙通信服务 (Kotlin)

class PulseBluetoothService(private val context: Context) {
    
    private var bluetoothGatt: BluetoothGatt? = null
    private val serviceUUID = UUID.fromString("0000180d-0000-1000-8000-00805f9b34fb")
    private val characteristicUUID = UUID.fromString("00002a37-0000-1000-8000-00805f9b34fb")
    
    // 连接手表
    fun connect(device: BluetoothDevice): Flow<ConnectionState> = callbackFlow {
        val callback = object : BluetoothGattCallback() {
            override fun onConnectionStateChange(gatt: BluetoothGatt, status: Int, newState: Int) {
                when (newState) {
                    BluetoothProfile.STATE_CONNECTED -> {
                        gatt.discoverServices()
                        trySend(ConnectionState.Connected)
                    }
                    BluetoothProfile.STATE_DISCONNECTED -> {
                        trySend(ConnectionState.Disconnected)
                        close()
                    }
                }
            }
            
            override fun onServicesDiscovered(gatt: BluetoothGatt, status: Int) {
                if (status == BluetoothGatt.GATT_SUCCESS) {
                    // 启用通知
                    val characteristic = gatt.getService(serviceUUID)
                        ?.getCharacteristic(characteristicUUID)
                    characteristic?.let {
                        gatt.setCharacteristicNotification(it, true)
                    }
                }
            }
            
            override fun onCharacteristicChanged(
                gatt: BluetoothGatt, 
                characteristic: BluetoothGattCharacteristic
            ) {
                // 接收脉象数据
                val data = characteristic.value
                val pulseData = parsePulseData(data)
                trySend(ConnectionState.DataReceived(pulseData))
            }
        }
        
        bluetoothGatt = device.connectGatt(context, false, callback)
        
        awaitClose {
            bluetoothGatt?.close()
        }
    }
    
    // 发送开始采集命令
    fun startPulseCollection(duration: Int = 60): Boolean {
        val command = PulseCommand.StartCollection(duration)
        return sendCommand(command)
    }
    
    // 发送停止采集命令
    fun stopPulseCollection(): Boolean {
        val command = PulseCommand.StopCollection
        return sendCommand(command)
    }
    
    // 请求历史记录
    fun requestHistoryRecords(startTime: Long, endTime: Long): Boolean {
        val command = PulseCommand.RequestHistory(startTime, endTime)
        return sendCommand(command)
    }
    
    private fun sendCommand(command: PulseCommand): Boolean {
        val characteristic = bluetoothGatt?.getService(serviceUUID)
            ?.getCharacteristic(characteristicUUID)
        
        characteristic?.value = command.toByteArray()
        return bluetoothGatt?.writeCharacteristic(characteristic) ?: false
    }
    
    private fun parsePulseData(data: ByteArray): PulseData {
        // 解析二进制数据
        val buffer = ByteBuffer.wrap(data).order(ByteOrder.LITTLE_ENDIAN)
        
        return PulseData(
            timestamp = buffer.getLong(),
            mainPulse = buffer.get().toInt().let { getPulseType(it) },
            pulseRate = buffer.get().toInt(),
            signalQuality = buffer.get().toInt() / 100f,
            ppgData = buffer.remainingBytes()
        )
    }
}

// 数据类定义
data class PulseData(
    val timestamp: Long,
    val mainPulse: String,
    val pulseRate: Int,
    val signalQuality: Float,
    val ppgData: ByteArray
)

sealed class ConnectionState {
    object Connected : ConnectionState()
    object Disconnected : ConnectionState()
    data class DataReceived(val data: PulseData) : ConnectionState()
}

sealed class PulseCommand {
    data class StartCollection(val duration: Int) : PulseCommand()
    object StopCollection : PulseCommand()
    data class RequestHistory(val startTime: Long, val endTime: Long) : PulseCommand()
    
    fun toByteArray(): ByteArray {
        return when (this) {
            is StartCollection -> byteArrayOf(0x01, duration.toByte())
            is StopCollection -> byteArrayOf(0x02)
            is RequestHistory -> {
                val buffer = ByteBuffer.allocate(17).order(ByteOrder.LITTLE_ENDIAN)
                buffer.put(0x03)
                buffer.putLong(startTime)
                buffer.putLong(endTime)
                buffer.array()
            }
        }
    }
}
```

---

*文档版本: v1.0*  
*最后更新: 2024年1月*
